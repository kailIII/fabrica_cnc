<?php/** * Slicely modified plugin for Sabre  * based on Sabre_DAV_Browser_Plugin class.  * * Browser Plugin * * This plugin provides a html representation, so that a WebDAV server may be accessed * using a browser. * * The class intercepts GET requests to collection resources and generates a simple  * html index.  *  * @package Sabre * @subpackage DAV * @copyright Copyright (C) 2007-2010 Rooftop Solutions. All rights reserved. * @author Evert Pot (http://www.rooftopsolutions.nl/) * @license http://code.google.com/p/sabredav/wiki/License Modified BSD License */class Elementit_Sabre_Plugin_Ajax extends Sabre_DAV_Browser_Plugin {   const GET_DIRS = 0;   const GET_FILES = 1;   const GET_BOTH = 2;      private $directoriesFirst = true;    private $json_data = null;   private $command = null;       public function __construct($dirsFirst, $enablePost=true) 	{       parent::__construct($enablePost); 	   $this->directoriesFirst = $dirsFirst;	   //get command	   if(isset($_REQUEST['command']))		   {			$this->command = $_REQUEST['command'];	   }    }		/**     * This method intercepts GET requests to collections and returns the html      *      * @param string $method      * @return bool      */    public function httpGetInterceptor($method, $uri) {        if ($method!='GET') return true;               /* $node = $this->server->tree->getNodeForPath($uri);        if ($node instanceof Sabre_DAV_IFile) return true;*/        $this->server->httpResponse->sendStatus(200);        $this->server->httpResponse->setHeader('Content-Type','text/html; charset=utf-8');        $this->server->httpResponse->sendBody(            $this->generateDirectoryIndex($uri)        );        return false;            }		    /**     * We need to extend only one method of Sabre_DAV_Browser_Plugin class.     *     * @param string $path      * @return string      */    public function generateDirectoryIndex($path) 	{					return $this->executeCommand($path);    }		/**	*	Execute custom command, by default return list of items	**/	private function executeCommand($path)	{		switch($this->command)		{			case "delete": 								$this->deletePath($path);				//Return contents of parent directory								return $this->getItems(dirname($path));				break;			default:								return $this->getItems($path);		}	}		/**	* method return json encoded list of items	**/	private function getItems($path)	{		$this->json_data = null;		$this->json_data->error = "";		$this->json_data->files = array();				try		{			$files = $this->server->getPropertiesForPath($path,array(				'{DAV:}displayname',				'{DAV:}resourcetype',				'{DAV:}getcontenttype',				'{DAV:}getcontentlength',				'{DAV:}getlastmodified',			),1);							if($this->directoriesFirst)			{				$this->getItemsArray($path, $files, self::GET_DIRS);				$this->getItemsArray($path, $files, self::GET_FILES);			}			else				$this->getItemsArray($path, $files, self::GET_BOTH);			} 		catch(Exception $e) {			$this->json_data->error=$e->getMessage();		}		return json_encode($this->json_data); 	}		/**	* Method delete specified item 	**/	private function deletePath($path)	{				$files = $this->server->getPropertiesForPath($path,array(			'{DAV:}displayname',			'{DAV:}resourcetype',			'{DAV:}getcontenttype',			'{DAV:}getcontentlength',			'{DAV:}getlastmodified',		),1);				$this->server->tree->delete($path);			}		/**	* Method fill $this->json_data->files array with list of items filtered by $whatToGet	**/	private function getItemsArray($path, $files, $whatToGet )	{				$json_item = null;		$node = null;		foreach($files as $k=>$file) 		{			try			{				if (rtrim($file['href'],'/')==$path) 					continue;				// This is the current directory, we can skip it				$json_item = null;								list(, $name) = Sabre_DAV_URLUtil::splitPath($file['href']);				$type = $this->getFileType($file);								if($whatToGet == self::GET_DIRS && $type != "Collection")					continue;				if($whatToGet == self::GET_FILES && $type == "Collection")					continue;								$json_item->type=$type;				$json_item->size = isset($file[200]['{DAV:}getcontentlength'])?(int)$file[200]['{DAV:}getcontentlength']:'';				$json_item->lastmodified = isset($file[200]['{DAV:}getlastmodified'])?$file[200]['{DAV:}getlastmodified']->getTime()->format(DateTime::RFC1123):'';				$json_item->fullPath = '/' . trim($this->server->getBaseUri() . ($path?$path . '/':'') . $name,'/');//Sabre_DAV_URLUtil::encodePath(				$json_item->displayName = isset($file[200]['{DAV:}displayname'])?$file[200]['{DAV:}displayname']:$name;				array_push($this->json_data->files, $json_item);				} 			catch(Exception $e) {				$this->json_data->error = $e->getMessage();			}		}		}		/**	* Method retur type of item	**/	private function getFileType($file)	{		$type = null;		if (isset($file[200]['{DAV:}resourcetype'])) {			$type = $file[200]['{DAV:}resourcetype']->getValue();			// resourcetype can have multiple values			if (is_array($type)) {				$type = implode(', ', $type);			}			// Some name mapping is preferred 			switch($type) {				case '{DAV:}collection' :					$type = 'Collection';					break;			}		}		// If no resourcetype was found, we attempt to use		// the contenttype property		if (!$type && isset($file[200]['{DAV:}getcontenttype'])) {			$type = $file[200]['{DAV:}getcontenttype'];		}		if (!$type) $type = 'Unknown';		return $type;	}}